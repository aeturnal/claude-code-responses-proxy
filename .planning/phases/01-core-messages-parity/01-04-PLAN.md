---
phase: 01-core-messages-parity
plan: 04
type: execute
wave: 4
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - src/app.py
  - src/handlers/messages.py
  - src/errors/anthropic_error.py
autonomous: true
must_haves:
  truths:
    - "User can POST /v1/messages and receive Anthropic-compatible response shape"
    - "Upstream OpenAI errors return deterministic Anthropic error envelopes"
  artifacts:
    - path: "src/handlers/messages.py"
      provides: "/v1/messages FastAPI route"
      exports: ["router"]
    - path: "src/errors/anthropic_error.py"
      provides: "Anthropic error envelope builder"
      exports: ["build_anthropic_error"]
    - path: "src/app.py"
      provides: "FastAPI app wiring"
      contains: "FastAPI()"
  key_links:
    - from: "src/handlers/messages.py"
      to: "src/mapping/anthropic_to_openai.py"
      via: "request mapping"
      pattern: "map_anthropic_request_to_openai"
    - from: "src/handlers/messages.py"
      to: "src/mapping/openai_to_anthropic.py"
      via: "response mapping"
      pattern: "map_openai_response_to_anthropic"
    - from: "src/handlers/messages.py"
      to: "src/transport/openai_client.py"
      via: "OpenAI Responses call"
      pattern: "create_openai_response"
    - from: "src/handlers/messages.py"
      to: "src/errors/anthropic_error.py"
      via: "error envelope builder"
      pattern: "build_anthropic_error"
---

<objective>
Expose /v1/messages with deterministic Anthropic-compatible responses and error envelopes.

Purpose: Deliver the Phase 1 user-facing endpoint with correct success and error shapes.
Output: FastAPI app + handler + error mapping for /v1/messages.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-messages-parity/01-RESEARCH.md
@.planning/phases/01-core-messages-parity/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Anthropic error envelope helper</name>
  <files>src/errors/anthropic_error.py</files>
  <action>
    - Implement build_anthropic_error(status_code, error_type, message, param=None, code=None, openai_error=None).
    - Return dict: {"type":"error","error":{"type":error_type,"message":message,"param":param,"code":code,"openai":openai_error}}.
    - Provide helper for mapping OpenAI error payloads into error_type (default "api_error" when unknown).
  </action>
  <verify>python -c "from src.errors.anthropic_error import build_anthropic_error; print(build_anthropic_error(400,'invalid_request_error','bad').keys())"</verify>
  <done>Deterministic Anthropic error envelope includes OpenAI details when present.</done>
</task>

<task type="auto">
  <name>Task 2: Implement /v1/messages handler and app wiring</name>
  <files>src/handlers/messages.py, src/app.py</files>
  <action>
    - Create FastAPI router with POST /v1/messages accepting MessagesRequest.
    - Map request via map_anthropic_request_to_openai, call create_openai_response, then normalize via map_openai_response_to_anthropic.
    - Catch OpenAIUpstreamError and return build_anthropic_error with upstream error payload and HTTP status code.
    - Add FastAPI exception handler for RequestValidationError to return 400 with build_anthropic_error("invalid_request_error", ...).
    - Wire router into FastAPI app in src/app.py.
  </action>
  <verify>python - <<'PY'
import asyncio
import httpx

from src.app import app
import src.handlers.messages as messages
from src.transport.openai_client import OpenAIUpstreamError


async def run():
    async def fake_success(_payload):
        return {
            "status": "completed",
            "output": [
                {
                    "type": "message",
                    "role": "assistant",
                    "content": [{"type": "output_text", "text": "ok"}],
                }
            ],
        }

    async def fake_error(_payload):
        raise OpenAIUpstreamError(401, {"error": {"type": "auth_error", "message": "bad key", "param": None, "code": None}})

    transport = httpx.ASGITransport(app=app)
    async with httpx.AsyncClient(transport=transport, base_url="http://test") as client:
        # Success path
        messages.create_openai_response = fake_success
        ok = await client.post(
            "/v1/messages",
            json={
                "model": "claude-3-7-sonnet-latest",
                "messages": [{"role": "user", "content": "hi"}],
                "max_tokens": 16,
            },
        )
        ok.raise_for_status()
        ok_body = ok.json()
        assert ok_body.get("type") == "message"
        assert ok_body.get("role") == "assistant"
        assert ok_body.get("content")[0].get("type") == "text"

        # Error path
        messages.create_openai_response = fake_error
        err = await client.post(
            "/v1/messages",
            json={
                "model": "claude-3-7-sonnet-latest",
                "messages": [{"role": "user", "content": "hi"}],
                "max_tokens": 16,
            },
        )
        assert err.status_code == 401
        err_body = err.json()
        assert err_body.get("type") == "error"
        assert err_body.get("error", {}).get("openai")


asyncio.run(run())
print("ok")
PY</verify>
  <done>/v1/messages returns Anthropic-compatible success and error envelopes when exercised locally.</done>
</task>

</tasks>

<verification>
- Start server and POST a minimal Anthropic request; response includes type=message, role=assistant, content list, stop_reason.
- Trigger upstream error (invalid API key) and verify Anthropic error envelope with OpenAI details.
</verification>

<success_criteria>
- /v1/messages accepts Anthropic request shape and returns Anthropic-compatible response shape.
- Upstream OpenAI errors map to deterministic Anthropic error envelopes with OpenAI details included.
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-messages-parity/01-04-SUMMARY.md`
</output>
