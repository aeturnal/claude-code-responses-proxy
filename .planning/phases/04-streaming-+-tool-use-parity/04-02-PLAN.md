---
phase: 04-streaming-+-tool-use-parity
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mapping/openai_stream_to_anthropic.py
  - src/mapping/__init__.py
autonomous: true
must_haves:
  truths:
    - "Anthropic SSE message/content block lifecycle events are emitted in order"
    - "Tool use input_json_delta fragments accumulate into finalized tool inputs"
  artifacts:
    - path: "src/mapping/openai_stream_to_anthropic.py"
      provides: "OpenAI stream â†’ Anthropic SSE translator"
    - path: "src/mapping/__init__.py"
      provides: "Exports streaming translator"
  key_links:
    - from: "src/mapping/openai_stream_to_anthropic.py"
      to: "src/mapping/openai_to_anthropic.py"
      via: "derive_stop_reason"
      pattern: "derive_stop_reason"
    - from: "src/mapping/openai_stream_to_anthropic.py"
      to: "json.loads"
      via: "tool input parsing"
      pattern: "json\.loads"
---

<objective>
Implement the OpenAI-to-Anthropic streaming translator with correct block lifecycle ordering and tool_use delta accumulation.

Purpose: Convert OpenAI streaming events into Anthropic-compatible SSE events with tool parity.
Output: SSE event strings representing Anthropic message/content block lifecycle events.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-streaming-+-tool-use-parity/04-RESEARCH.md
@src/mapping/openai_to_anthropic.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Anthropic SSE formatting + stream state helpers</name>
  <files>src/mapping/openai_stream_to_anthropic.py</files>
  <action>
Create a new module that defines:

- `format_sse(event: str, payload: Dict[str, Any]) -> str` that returns `event: ...\ndata: ...\n\n` with `json.dumps(payload)`.
- A small state container (dataclass or class) to track:
  - `message_started: bool`
  - `next_block_index: int`
  - `block_index_by_key: Dict[Tuple[int,int,str], int]` (map OpenAI output/content indices to Anthropic block indices)
  - `tool_input_buffers: Dict[int, str]` keyed by Anthropic block index
  - `last_usage: Optional[Dict[str, Any]]` for final usage logging
- Helper methods to allocate a new block index and initialize tool input buffers.
  </action>
  <verify>python -m compileall src</verify>
  <done>SSE formatting and state helpers exist and are ready for the translator.</done>
</task>

<task type="auto">
  <name>Task 2: Translate OpenAI stream events to Anthropic SSE lifecycle</name>
  <files>src/mapping/openai_stream_to_anthropic.py</files>
  <action>
Implement `async def translate_openai_events(events: AsyncIterator[Dict[str, Any]]) -> AsyncIterator[str]` that yields Anthropic SSE strings using the state helper.

Mapping rules (derive from OpenAI event payloads):

- **message_start**: On the first `response.created` (or first event if none), emit `event: message_start` with `{type: "message_start", message: {type: "message", role: "assistant", content: [], stop_reason: None, stop_sequence: None}}`. Include `id`/`model` from OpenAI response if available.

- **text blocks**:
  - On `response.content_part.added` (or equivalent) where `part.type == "output_text"`, allocate a new block index and emit `content_block_start` with `{type: "content_block_start", index, content_block: {type: "text", text: ""}}`.
  - On `response.output_text.delta`, emit `content_block_delta` with `{type: "content_block_delta", index, delta: {type: "text_delta", text}}`.
  - On `response.output_text.done` (or `content_part.done`), emit `content_block_stop` for the index.

- **tool_use blocks**:
  - On `response.output_item.added` where `item.type == "function_call"`, allocate a new block index, initialize an empty buffer, and emit `content_block_start` with `{type: "content_block_start", index, content_block: {type: "tool_use", id: item.call_id, name: item.name, input: {}}}`.
  - On `response.function_call_arguments.delta`, append `partial_json` to the buffer and emit `content_block_delta` with `{type: "content_block_delta", index, delta: {type: "input_json_delta", partial_json}}`.
  - On `response.function_call_arguments.done`, parse the accumulated buffer using `json.loads` (fallback to raw string on failure), then emit `content_block_stop` and include the finalized tool input in a `content_block` field: `{type: "content_block_stop", index, content_block: {type: "tool_use", id, name, input}}`. Clear the buffer.

- **message_delta + message_stop**:
  - On `response.completed` (or equivalent), compute `stop_reason` using `derive_stop_reason(response)` and extract usage from `response.usage` if present. Emit `message_delta` with cumulative usage and then `message_stop`.

- **ping/unknown**: If event type is `ping`, emit a `ping` event with `{type: "ping"}`. Ignore unknown events safely without breaking the stream.

Use index mapping keys from OpenAI events (e.g., `output_index`, `content_index`, `item.type`) to ensure deterministic block ordering; fall back to "most recent open block" only when indices are absent.
  </action>
  <verify>python -m compileall src</verify>
  <done>Translator yields Anthropic SSE events in strict lifecycle order with tool input_json_delta buffering.</done>
</task>

<task type="auto">
  <name>Task 3: Export streaming translator from mapping package</name>
  <files>src/mapping/__init__.py</files>
  <action>
Export `translate_openai_events` (and state helper if needed) from `src.mapping` for handler imports.
  </action>
  <verify>python -m compileall src</verify>
  <done>`translate_openai_events` is importable via `from src.mapping import translate_openai_events`.</done>
</task>

</tasks>

<verification>
- `python -m compileall src` succeeds.
</verification>

<success_criteria>
- OpenAI streaming events are translated into Anthropic-compatible SSE lifecycle events with tool_use input_json_delta accumulation.</success_criteria>

<output>
After completion, create `.planning/phases/04-streaming-+-tool-use-parity/04-02-SUMMARY.md`
</output>
